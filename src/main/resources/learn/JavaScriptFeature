JavaScript:

    单线程编程语言, 只有一个Call Stack(调用堆栈), 所有并发行为均由单线程模拟实现
        | 同步任务: 主线程执行, 主线程当前任务执行完毕(主线程执行栈空)，去Event Queue读取排队的回调函数，进入主线程执行（Event Loop执行机制）
        | 异步任务: 进入Event Table执行，事件完成后注册回调函数(success/error等)至Event Queue

    任务定义, 不同类型的任务进入不同的Event Queue
        | macro-task: 宏任务, 整体代码script、setTimeout、setInterval等
        | micro-task: 微任务, Promise、process.nextTick等
        | 主线程循环 -> 整体代码(宏任务) -> 微任务队列 -> 宏任务队列 -> 微任务队列 ...

    setTimeout(function(){}, ms)
        | 计时完成后将回调方法注册至EventQueue， 还需要等待主线程完成所有任务后调用
        | setTimeout(fn,0), 主线程一有空闲就执行, HTML标准规定最低延迟4ms

    setInterval(function(){}, ms)
        | 循环执行任务, 每隔ms时间将function加入 Event Queue

    new Promise(function(){}).then(function(){})
        | new Promise的fn函数立即执行， then的fn函数分发到微任务的Event Queue
    process.nextTick(callback) - node.js
        | callback分发到微任务的Event Queue


    全局上下文: this值指向全局对象, 浏览器中为Window对象
    函数上下文: 函数被调用时创建, 如果被引用对象调用, this值被设置成该对象, 否则被设置为全局对象或undefined(严格模式)
        | 创建阶段
            | 决定this值
            | 创建词法环境, 存储函数声明和变量(let/const)
            | 创建变量环境, 存储var变量绑定
        | 执行阶段

        | let
        | const
        | var


页面启动函数：
        | $(document).ready(function(){}): DOM结构绘制完毕后就执行，可以定义多个
            -> 等价于 $(function(){});
            -> 等价于 $().ready(function(){});
        | window.onload = function(){}  : 页面所有元素都加载完毕，包括图片等所有元素。只能执行一次(最后定义的一个)

HTML页面加载顺序：从上到下
    用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；
    浏览器开始载入html代码，发现<head>标签内有一个<link>标签引用外部CSS文件；
    浏览器又发出CSS文件的请求，服务器返回这个CSS文件；
    浏览器继续载入html中<body>部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；
    浏览器在代码中发现一个<img>标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面 的代码；
    服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；
    浏览器发现了一个包含一行Javascript代码的<script>标签，赶快运行它；
    Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个<div> （style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码；
    终于等到了</html>的到来，浏览器泪流满面……
    等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下<link>标签的CSS路径；
    浏览器召集了在座的各位<div><span><ul><li>们，“大伙儿收拾收拾 行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。