NOTE:


>> 条件注解:
Spring Boot的设计是先加载应用级配置, 随后再考虑(根据条件注解)自动配置类
    @ConditionalOnMissingBean
    @ConditionalOnWebApplication
    @ConditionalOnClass
    @ConditionalOnProperty(name="", havingVaule="", matchIfMissing=true) -> 根据配置文件对应的Environment
    @Conditional(XxxConditional.class) 自定义的条件配置类(实现Condition接口)


>> 属性配置:
Spring Boot能从多种属性源获得属性(优先级递减)
    (1) 命令行参数  -> 指定启动端口 java -Dserver.port=9000 -jar bootsample.jar
    (2) java:comp/env里的JNDI属性
    (3) JVM系统属性
    (4) 操作系统环境变量
    (5) 随机生成的带random.*前缀的属性(在设置其他属性时,可以引用它们,比如${random.long})
    (6) 应用程序以外的application.properties或者application.yml文件
    (7) 打包在应用程序内的application.properties或者application.yml文件
    (8) 通过@PropertySource(value = "classpath:redis.properties")标注的属性源
    (9) 默认属性


>> springboot读取应用配置文件application.properties三种方式
    (1) Environment类(Autowired)获取键值对
    (2) @Value(${"server.port"})自动注入属性, 通过AutowiredAnnotationBeanPostProcessor实现
    (3) 将一组属性自动注入到一个配置类中, @ConfigurationProperties("prefix"), springboot处理注解时将"-_"去掉转化为Java命名规范


>> 运行环境配置:
    设置spring.profiles.active=production 就能激活Profile, 对于不同配置Bean的创建使用@Profile("production")
    在resources下创建application-{profile}.properties的配置文件这些配置文件在激活时会覆盖application.properties


>> Actuator
    | springboot2 默认不启用所有的监控
    | 端点,使用endpoints.shutdown/metrics/*.enabled = true/false进行配置:
        GET /autoconfig 提供了一份自动配置报告,记录哪些自动配置条件通过了,哪些没通过
        GET /configprops 描述配置属性(包含默认值)如何注入Bean
        GET /beans 描述应用程序上下文里全部的Bean,以及它们的关系
        GET /dump 获取线程活动的快照
        GET /heapdump 获取dump文件(类似jmap工具) -> 使用jhat分析(OQL查询语句)
        GET /env 获取全部环境属性
        GET /env/{name} 根据名称获取特定的环境属性值
        GET /health 报告应用程序的健康指标,这些值由HealthIndicator的实现类提供
        GET /info 获取应用程序的定制信息,这些信息由info打头的属性提供,需配置在application.properties
        GET /mappings 描述全部的URI路径,以及它们和控制器(包含Actuator端点)的映射关系
        GET /metrics 报告各种应用程序度量信息及运行时数据,比如内存用量和HTTP请求计数
        GET /metrics/{name} 报告指定名称的应用程序度量值
        POST /shutdown 关闭应用程序, 要求endpoints.shutdown.enabled设置为true
        GET /trace 提供基本的HTTP请求跟踪信息(时间戳、HTTP头等),存储在内存中,默认100条
    | 除了REST端点接口,Actuator还提供了远程Shell及JMX(MBean)的方式进行管理。


>> Maven常用命令
    mvn compile: 编译工程
    mvn package: 编译并打包工程,target中生成jar或war
    mvn install: 打包并安装到本地仓库
    mvn deploy: 到包安装到本地及远程仓库
    mvn clean: 删除target目录


>> Spring MVC 参数
    Model model: 对应与MVC框架中的模型,可用于视图渲染
    JavaBean: 将参数映射到对象实例中
    @PathVariable: 获取路径参数{param}映射到方法参数
    @RequestParam: HTTP请求的参数,自动转换类型
    @RequestHeader: HTTP请求头的参数,自动转换类型
    @RequestBody: 表明请求的HTTP消息体内容是JSON,将请内容转换为指定的对象,默认使用HttpMessageConverters
    ModelAndView: 包含模型和视图路径
    @RequestPart: 用于文件上传,对应HTTP协议的multipart/form-data
    MultipartFile: 处理文件上传
    @ModelAttribute: 使用该注解的变量将作为Model的一个属性
        | 注解在Controller的方法上,此方法会首先被调用并将结果作为Model属性保存,然后调用对应的Controller处理方法
    InputStream/Reader, OutputStream/Writer: 获取Servlet API中的输入输出流
    @InitBinder: 为Controller添加自定义的HTTP参数解析器

使用@ModelAttribute注解的实体类接收前端发来的数据格式需要为"x-www-form-urlencoded"，@RequestBody注解的实体类接收前端的数据格式为JSON(application/json)格式。

如果为get请求时，后台接收参数的注解应该为RequestParam，如果为post请求时，则后台接收参数的注解就是为RequestBody


@RequestBody

作用：
      i) 该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上；
      ii) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。
使用时机：
A) GET、POST方式提时， 根据request header Content-Type的值来判断:
    application/x-www-form-urlencoded， 可选（即非必须，因为这种情况的数据@RequestParam, @ModelAttribute也可以处理，当然@RequestBody也能处理）；
    multipart/form-data, 不能处理（即使用@RequestBody不能处理这种格式的数据）；
    其他格式， 必须（其他格式包括application/json, application/xml等。这些格式的数据，必须使用@RequestBody来处理）；
B) PUT方式提交时， 根据request header Content-Type的值来判断:
    application/x-www-form-urlencoded， 必须；
    multipart/form-data, 不能处理；
    其他格式， 必须；
说明：request的body部分的数据编码格式由header部分的Content-Type指定；

Ant路径表达式: *表示匹配任意字符 **表示匹配任意路径 ?匹配单个字符


>> Spring boot 支持JSR-303及Bean验证框架,默认使用Hibernate Validator
    | @Null @NotNull @NotBlank(字符串不为空或不是空格字符串) @NotEmpty(对象不为Null,集合不为空)
    | @Size(min=,max=)字符串和集合长度 @Length(字符串大小)
    | @Min @Max(验证数字的大小),@Digits(integer=,fraction=)验证数字是否符合指定格式,@Range(min=,max=)验证数字是否在指定区间
    | @Email(验证是否是邮件格式), @Pattern（验证对象是否符合正则表达式）
在controller方法中给参数加上@Validated可触发一次校验，此时参数中还应提供BindingResult result来获取验证的结果
    验证的结果需要配置AbstractErrorController来处理
    或者@RestControllerAdvice + @ExceptionHandler进行异常拦截处理


>> Jackson三种层次的序列化和反序列化方式:
    | 使用JsonParser解析JSON(生成Tokens), 使用JsonGenerator生成JSON, 底层方式
    | 使用树遍历Tree Traversing, JSON被读入JsonNode对象中, 类似XML DOM, 适用于没有POJO对应的JSON
    | 使用DataBind, POJO <-> JSON, 可以利用注解字段来实现自定义, readVaule/writeValueAsString
        注解:
            @JsonProperty 属性, 指定key的别名
            @JsonNaming 类或者属性, 指定命名策略, 如LowerCaseWithUnderscoresStrategy.class
            @JsonIgnore 属性, 忽略此属性
            @JsonIgnoreProperties({"xx","yy"}) 类, 忽略一组属性
            @JsonAnySetter 方法, 接受key,value两个参数, 反序列化时未找到对应属性的键值对调用该方法, 一般向map中添加
            @JsonAnyGetter 方法, 标注在返回Map的方法上, Jackson会取出所有键值对进行序列化
            @JsonFormat 属性, 用于日期格式化
            @JsonSerialize 类, 指定一个JsonSerializer<T>实现类自定义序列化, 调用JsonGenerator
            @JsonDeserializer 类, 指定一个JsonDeserializer<T>实现类自定义反序列化, 调用JsonParser
            @JsonView, 类或者属性, 定义序列化组, Controller方法可以选择@JsonView来序列化这一组属性


>> 数据库访问DAO: 以SQL为中心(更灵活, JdbcTemplate/MyBatis)、以对象为中心(ORM, Hibernate)
    | Spring Data JPA 采用Hibernate实现
        | 配置文件
              spring.jpa.hibernate.ddl-auto: none, 是否自动创建库(一般不用)
              spring.jpa.show-sql: false, 是否自动打印SQL
        | 实体注解
              @Entity(标注实体类)、@Id(标注主键)、@Generated(标注主键生成策略)、@Column(标注列,可指定列名)
              @ManyToOne(多个当前实体对应一个注解字段, @JoinColumn指定外键)、@OneToMany(One端必须使用mappedBy指定Many端的对象)
        | repository: Spring Data 核心概念, 支持关系数据库和Nosql库(redis、MongoDB、Elasticsearch)
            | CrudRepository: 提供基本的增删改查、批量操作
            | PagingAndSortingRepository: 继承CrudRepository, 提供附加分页、排序的查询功能
            | JpaRepository: 继承PagingAndSortRepository, 提供增删改查、Example查询
            | 自定义Repository 继承 JpaRepository
                | 可以添加查询方法(方法名和参数符合规定)
                    -> 方法以findBy/getBy/queryBy开头
                    -> 方法名包含多个实体属性, 属性间以And和Or连接, 支持Between、LessThan、GreaterThan、Like/NotLike等
                    -> 支持排序, 方法名包含OrderByXXXAsc/Desc
                    -> 可通过Top、First限定查询结果集
                | 添加 @Query(JPQL语句或SQL语句)注解 的方法
                    -> 支持参数 xxx=?1 或者 命名参数 =:name
                    -> 可使用Pageable和Sort协助分页和排序
                    -> 对于更新、删除操作, 必须要添加 @Modifying注解
                |使用JPA Query, EntityManager(可注入Service)提供了实体操作的所有接口,可以实现复杂查询, 弥补Repository的不足


>> 日志: Springboot默认使用LogBack作为日志实现, 使用Apache Commons Logging作为日志接口
    | 在配置文件可设置日志输出级别 logging.level.root(.org/.com)=info
    | logging.file(设置日志存放路径)、logging.path(指定日志存放目录)、logging.pattern.console/file(指定日志输出格式)
    | 在resources目录下使用logback.xml 或 logback-spring.xml也可进行定制


>> JUnit: 回归测试框架, 编写和运行可重复的单元测试(白盒测试)
    | 注解: @Before(每个测试方法之前执行)、@BeforeClass(整个测试类开始时执行)、@After、@AfterClass、@Test、@Ignore
    | Assert类: 条件不成立时抛异常
    | 执行每个@Test方法都会创建一个新的实例， 但是Spring上下文不会重新加载
    | Springboot 单元测试会在运行结束后进行事务回滚
    | 集成Mockito 模拟未完成的类或者不便于调用的接口/类
        -> @MockBean可以自动注入模拟实现(使用Mockito的静态方法定义bean的参数和返回值), 或者使用mock()方法生成模拟对象
    | 测试Controller代码(MVC): 类注解@WebMvcTest(xxxController.class)， @Autowired MockMvc
        -> 在该类型测试中@Service等注解的类不会被扫锚注册为容器内的Bean, 需要使用@MockBean模拟实现
        -> mockMvc.perform(get/post/multipart).param(...).content(...).accept(...).header(...).addExpect(...);


>> RESTful架构风格
    | 建议使用"api"作为上下文, 增加版本标识: http://192.168.0.1/api/v1.1/xxx
    | POST(新增资源)/PUT(完整更新资源)/GET(查询资源)/PATCH(部分更新资源)/DELETE(删除资源)/HEAD(仅返回HTTP头信息)/OPTIONS(查看URI支持的方法)
    | 200(请求成功)/400(错误的请求/参数不对)/404(资源不存在)/405(HTTP Method不允许)/406(无法使用请求的特性来返回资源)/409(资源冲突)/500(服务器内部错误)
    | @RestController(等价于@Controller和@ResponseBody)
    | Springboot 提供 RestTemplate(使用RestTemplateBuilder创建) 访问所有REST服务的接口


>> Spring Session: 分布式Web服务器同时提供服务, 使用Nginx提供反向代理, 使用Redis存放Session(Hash结构)
    | spring session 独立于应用服务器, 同一用户可以建立多个session(多账户),可方便实现切换登录
    | spring session 能够实现websocket与Http请求都能保持Http Session处于活跃状态
    | spring session 可以获取非web请求(http请求)的session
    | 需要测试过期时间

    | 在请求/响应周期中, 客户端和服务端需要协商同意session id的传递方式
        -> Http请求: 可以放在Cookie(默认)或者Header中 CookieHttpSessionStrategy/HeaderHttpSessionStrategy
        -> Https请求: 可以使用SSL session id
        -> JMS请求: session id存储在JMS Header中...
    | Springboot默认使用Tomcat的Session实现(StandardSessionFacade)

    | SpringSession通过(servlet规范)Filter拦截器生成Spring管理的Session, 拦截所有的web应用请求(Filter链中第一个)
        ->  自定义getSession实现类: SessionRepositoryRequestWrapper extends HttpServletRequestWrapper
    | 修改配置: spring.session.store-type=redis|jdbc(自动创建两张表)|mongodb|none


    | Nginx 命令
        -> nginx 启动Nginx, 默认端口80
        -> nginx -s stop/quit: 快速停止服务器/等待请求处理完毕关闭服务器
        -> nginx -s reload: 重新加载配置文件
    | Nginx 配置(conf/nginx.conf):
        -> http块: 可以嵌套多个Server, 定义代理、缓存、日志等
        -> location块: 配置请求的路由
        -> 默认论询策略, 可设置ip_hash使相同ip总是反向到相同的服务器

>> 	/**
   	 *  CRON 解释
   	 *  格式： Seconds Minutes Hours DayofMonth Month DayofWeek (Year)
   	 *
   	 * Seconds: , * - / 0-59
   	 * Minutes: , * - / 0-59
   	 * Hours: , * - / 0-24
   	 * DayofMonth:  , * - / ? L W C 0-31
   	 * Month: , * - / 1-12 JAN-DEC
   	 * DayofWeek: , * - / ? L C # 1-7 SUN-SAT
   	 *
   	 * 其中：
   	 *  <*>表示任意值
   	 *  <?>表示任意值
   	 *  <A/B>表示从A时刻每隔B个时间段触发一次
   	 *  <A,B>表示枚举，在A和B时刻均触发
   	 *  <5L>表示最后一个星期四触发
   	 *  <W>表示有效工作日,周一到周五
   	 *  <LW>表示某个月最后一个工作日
   	 *  <4#2>表示某个月第二个星期三
   	 *
   	 */

>> Zookeeper 分布式协调器(本身也是分布式高可用)
    | curator 封装Java API
    | 节点通过路径来表示, 可以包含一定的数据(2MB字节), 还包含更新的版本、收件戳
        -> 分为临时节点和持久化节点、顺序节点(带有序列号的节点,可判断创建先后顺序)
        -> 节点可以被监控, 删除或更新时客户端将收到通知, 监控失效
    | zkCli 基本命令
        -> help 查看帮助
        -> ls /path 查看路径下的节点
        -> create /path value 创建节点
        -> create -e /path value 创建临时节点
        -> create -s /path/prefix value1 创建顺序节点(同一节点下多个序列值, [prefix0000, prefix0001, prefix0002])
        -> get /path 获取节点数据
            | 返回创建时cZxid、最后更新mZxid、创建时间ctime、修改时间mtime、更新次数dataVersion、
            | ACL授权更新次数aclVersion、临时节点会话ID、节点数据长度dataLength、子节点个数numChildren
        -> delete /path 删除节点
        -> set /path data 设置节点数据
        -> watch: ls命令和get命令可增加监听操作
    | 领导选取: 多个客户端同时创建临时顺序节点 create -s -e /election/node 顺序最小的为领导者
    | 分布式锁: 创建/locks/xxx的节点, 创建成功则获取了锁, 失败则监听节点等待节点被删除, 获取锁的客户端执行完成后删除节点
        -> 也可以类似领导选取, 实现获取锁的排队(公平锁)
    | 服务注册: 创建存储服务列表的节点 create /service/modular data
        -> 对应模块的服务上线: create -e -s /service/modular/s- ip:port
        -> 客户端调用服务时读取/service/modular/下所有节点,随机选择获取服务地址
    | Curator应用场景
        -> 领导节点选取
        -> 分布式锁
        -> 分布式读写所
        -> 共享信号量
        -> 栅栏和双重Double Barrier
        -> 分布式计数器(integer/long)
        -> 分布式队列和分布式优先级队列
        -> 服务注册发现 curator-x-discovery
    | Curator:
        -> client.create().withMode().forPath("/path", value);
        -> client.setDate().forPath("/path", value);
        -> getDate/checkExist/watched
        -> CuratorListener接口添加事件监听

>> Spring Cache对Cache进行了抽象
    | @Cacheable 、@CachePut 、@CacheEvict、@Cache(综合多个)、@CacheConfig(类注解,指定该类所有方法的缓存名称)
        -> 生成动态代理类,调用方法前先调用缓存, 不存在则执行方法
        -> Key生成器: KeyGenerator接口(未指定键值，将调用)
        -> 通常使用SpEL指定Key(cacheName::key为唯一标识): #param.field, 支持条件表达式condition/unless， #result表示返回结果
    | 内置基于内存的缓存管理器Simple, 使用ConcurrentHashMap实现
        -> spring.cache.type=Simple/None/Redis/Generic(自定义, 添加CacheManager的实现)
    | 可集成Redis、EhCache
    | 缓存策略: 最大容量、过期时间


Mybatis:
@Select 是查询类的注解，所有的查询均使用这个
@Result 修饰返回的结果集，关联实体类属性和数据库字段一一对应，如果实体类属性和数据库属性名保持一致，就不需要这个属性来修饰。
@Insert 插入数据库使用，直接传入实体类会自动解析属性到对应的值
@Update 负责修改，也可以直接传入对象
@delete 负责删除

>> Junit
@BeforeClass 在所有测试方法前执行一次，一般在其中写上整体初始化的代码
@AfterClass 在所有测试方法后执行一次，一般在其中写上销毁和释放资源的代码
@Before 在每个测试方法前执行，一般用来初始化方法（比如我们在测试别的方法时，类中与其他测试方法共享的值已经被改变，为了保证测试结果的有效性，我们会在@Before注解的方法中重置数据）
@After 在每个测试方法后执行，在方法执行完成后要做的事情
@Test(timeout = 1000) 测试方法执行超过1000毫秒后算超时，测试将失败
@Test(expected = Exception.class) 测试方法期望得到的异常类，如果方法执行没有抛出指定的异常，则测试失败
@Ignore(“not ready yet”) 执行测试时将忽略掉此方法，如果用于修饰类，则忽略整个类
@Test 编写一般测试用例
@RunWith 在JUnit中有很多个Runner，他们负责调用你的测试代码，每一个Runner都有各自的特殊功能，你要根据需要选择不同的Runner来运行你的测试代码。


@Autowired Spring, 默认按照类型装配 可结合@Qualifier指定名称
@Resource JDK，默认按照名称装配



    /**
     *      @Pointcut: 表示一组切点，定义了Advice（建言）将要发生的地方
     *          | arg(): 参数为指定类型的执行方法
     *          | @args(): 参数由指定注解标注的执行方法
     *          | execution(): 用于匹配连接点的执行方法
     *          | this(): 限制连接点匹配 AOP 代理的 Bean 引用为指定类型的类
     *          | target(): 限制连接点匹配特定的执行对象，这些对象对应的类要具备指定类型注解
     *          | within(): 限制连接点匹配指定类型
     *          | @within(): 限制连接点匹配指定注释所标注的类型
     *          | @annotation(): 限制匹配带有指定注释的连接点
     *      Advice:
     *          | @Before
     *          | @Around
     *          | @After
     *          | @Finally
     */


验证分两种：对封装的Bean进行验证  或者  对方法简单参数的验证


Spring Validation验证框架对参数的验证机制提供了@Validated（Spring's JSR-303规范，是标准JSR-303的一个变种），
javax提供了@Valid（标准JSR-303规范），配合BindingResult可以直接提供参数验证结果。

@Validated：用在方法入参上无法单独提供嵌套验证功能。不能用在成员属性（字段）上，也无法提示框架进行嵌套验证。能配合嵌套验证注解@Valid进行嵌套验证。
@Valid：用在方法入参上无法单独提供嵌套验证功能。能够用在成员属性（字段）上，提示验证框架进行嵌套验证。能配合嵌套验证注解@Valid进行嵌套验证。
@Validated 是只用spring  Validator 校验机制使用，@Validated和BindingResult bindingResult是配对出现，并且形参顺序是固定的（一前一后）。
@Valid是使用hibernate validation的时候使用
如果方法中有BindingResult类型的参数，spring校验完成之后会将校验结果传给这个参数。通过BindingResult控制程序抛出自定义类型的异常或者返回不同结果。


@Valid	被注释的元素是一个对象，需要检查此对象的所有字段值
     Bean Validation 中内置的 constraint
     @Null   被注释的元素必须为 null
     @NotNull    被注释的元素必须不为 null
     @AssertTrue     被注释的元素必须为 true
     @AssertFalse    被注释的元素必须为 false
     @Min(value)     被注释的元素必须是一个数字，其值必须大于等于指定的最小值
     @Max(value)     被注释的元素必须是一个数字，其值必须小于等于指定的最大值
     @DecimalMin(value)  被注释的元素必须是一个数字，其值必须大于等于指定的最小值
     @DecimalMax(value)  被注释的元素必须是一个数字，其值必须小于等于指定的最大值
     @Size(max=, min=)   被注释的元素的大小必须在指定的范围内
     @Digits (integer, fraction)     被注释的元素必须是一个数字，其值必须在可接受的范围内
     @Past   被注释的元素必须是一个过去的日期
     @Future     被注释的元素必须是一个将来的日期
     @Pattern(regex=,flag=)  被注释的元素必须符合指定的正则表达式

     Hibernate Validator 附加的 constraint
     @NotBlank(message =)   验证字符串非null，且长度必须大于0
     @Email  被注释的元素必须是电子邮箱地址
     @Length(min=,max=)  被注释的字符串的大小必须在指定的范围内
     @NotEmpty   被注释的字符串的必须非空
     @Range(min=,max=,message=)  被注释的元素必须在合适的范围内

Session生命周期
浏览器访问服务器时，服务器会创建一个session对象（有一个sessionId）。服务器在默认的情况下，会将sessionId以cookie的机制发送给浏览器。当浏览器再次访问服务器时，会将sessionId发送给服务器，服务器依据sessionId就可以找到对应的session对象。服务器以此方式管理用户的状态。
　　Session存储在服务器端，一般放置在服务器的内存中（为了高速存取），Sessinon在用户访问第一次访问服务器时创建，需要注意只有访问JSP、Servlet等程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session，可调用request.getSession(true)强制生成Session。
　　Session什么时候失效？
    　　1. 服务器会把长时间没有活动的Session从服务器内存中清除，此时Session便失效。Tomcat中Session的默认失效时间为20分钟。
    　　2. 调用Session的invalidate方法。

SPring-session
    # 存储 Session 数据,数据类型hash
    Key：spring:session:sessions:XXXXXXX

    # Redis TTL触发Session 过期。(Redis 本身功能)，数据类型：String
    Key：spring:session:sessions:expires:XXXXX
    #执行 TTL key ，查看剩余生存时间

    #定时Job程序触发Session 过期。(spring-session 功能)，数据类型：Set
    Key：spring:session:expirations:XXXXX

浏览器的cookie的话，会发现有一个name为“SESSION”的cookie，其值为redis中spring session key的一部分
Cookie过期设置为最大的可能值是因为cookie是在会话创建的时候设置。如果它被设置成和session过期一样的话，当用户使用session时session可以更新，但是cookie过期之后不会更新，从而将会导致过期而被限定。

Spring Session下的Redis存储结构：
    spring:session是默认的Redis HttpSession前缀
    每一个session都会创建3组数据:
        -> spring:session:sessions:xxxxxxxx： hash结构，存储session键值对及创建时间、最大失效时间、最后访问时间
        -> spring:session:sessions:expires:xxxx ： 用于ttl过期时间记录
        -> spring:session:expirations:1515135000000: set结构，记录过期时间
        redis清除过期key的行为是一个异步行为且是一个低优先级的行为，用文档中的原话来说便是，可能会导致session不被清除。于是引入了专门的expiresKey，来专门负责session的清除，包括我们自己在使用redis时也需要关注这一点。在开发层面，我们仅仅需要关注第三个key就行了。
Redis的强大之处在于支持KeySpace Notifiction——键空间通知。即可以监视某个key的变化，如删除、更新、过期。当key发生上述行为是，以便可以接受到变化的通知做出相应的处理。
spring-session为了能够及时的产生Session的过期时的过期事件，所以增加了：
    spring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe
    spring:session:expirations:1439245080000
    spring-session中有个定时任务，每个整分钟都会查询相应的spring:session:expirations:整分钟的时间戳中的过期SessionId，然后再访问一次这个SessionId，即spring:session:sessions:expires:SessionId，以便能够让Redis及时的产生key过期事件——即Session过期事件。

Redis会为每个RedisSession存储三个k-v。

第一个k-v用来存储Session的详细信息，包括Session的过期时间间隔、最近的访问时间、attributes等等。这个k的过期时间为Session的最大过期时间 + 5分钟。如果默认的最大过期时间为30分钟，则这个k的过期时间为35分钟
第二个k-v用来表示Session在Redis中的过期，这个k-v不存储任何有用数据，只是表示Session过期而设置。这个k在Redis中的过期时间即为Session的过期时间间隔
第三个k-v存储这个Session的id，是一个Set类型的Redis数据结构。这个k中的最后的1439245080000值是一个时间戳，根据这个Session过期时刻滚动至下一分钟而计算得出。

简单描述下，为什么RedisSession的存储用到了三个Key，而非一个Redis过期Key。
对于Session的实现，需要支持HttpSessionEvent，即Session创建、过期、销毁等事件。当应用用监听器设置监听相应事件，Session发生上述行为时，监听器能够做出相应的处理。
Redis的强大之处在于支持KeySpace Notifiction——键空间通知。即可以监视某个key的变化，如删除、更新、过期。当key发生上述行为是，以便可以接受到变化的通知做出相应的处理。
spring-session为了能够及时的产生Session的过期时的过期事件，所以增加了：

spring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe
spring:session:expirations:1439245080000

spring-session中有个定时任务，每个整分钟都会查询相应的spring:session:expirations:整分钟的时间戳中的过期SessionId，然后再访问一次这个SessionId，即spring:session:sessions:expires:SessionId，以便能够让Redis及时的产生key过期事件——即Session过期事件。


spring-session分为以下核心模块：
SessionRepositoryFilter：Servlet规范中Filter的实现，用来切换HttpSession至Spring Session，包装HttpServletRequest和HttpServletResponse
HttpServerletRequest/HttpServletResponse/HttpSessionWrapper包装器：包装原有的HttpServletRequest、HttpServletResponse和Spring Session，实现切换Session和透明继承HttpSession的关键之所在
Session：Spring Session模块
SessionRepository：管理Spring Session的模块
HttpSessionStrategy：映射HttpRequst和HttpResponse到Session的策略

SessionRepositoryRequestWrapper继承Servlet规范中定义的包装器HttpServletRequestWrapper。HttpServletRequestWrapper是Servlet规范api提供的用于扩展HttpServletRequest的扩张点——即装饰器模式，可以通过重写一些api达到功能点的增强和自定义。

Tips：装饰器模式
装饰器模式（包装模式）是对功能增强的一种绝佳模式。实际利用的是面向对象的多态性实现扩展。Servlet规范中开放此HttpServletRequestWrapper接口，是让developers自行扩展实现。这种使用方式和jdk中的FilterInputStream/FilterInputStream如出一辙。

适配器模式
spring-session单独抽象出Session层接口，可以应对多种场景下不同的session的实现，然后通过适配器模式将Session适配成HttpSession的接口，精妙至极

Session是spring-session对session的抽象，主要是为了鉴定用户，为Http请求和响应提供上下文过程，该Session可以被HttpSession、WebSocket Session，非WebSession等使用。定义了Session的基本行为：
    getId：获取sessionId
    setAttribute：设置session属性
    getAttribte：获取session属性

策略模式
策略模式是一个传神的神奇模式，是java的多态非常典型应用，是开闭原则、迪米特法则的具体体现。将同类型的一系列的算法封装在不同的类中，通过使用接口注入不同类型的实现，以达到的高扩展的目的。一般是定义一个策略接口，按照不同的场景实现各自的策略。