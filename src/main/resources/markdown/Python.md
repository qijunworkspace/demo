# Python学习

## 一、Python基础

Python的语法比较简单，采用缩进方式：

```python
#!/usr/bin/env python3
# This is Python code
a = input("Please enter youer number: ")
try:
    b = int(a)
    if b >= 10:
        print("Your number is bigger than 10.")
	else:
        print("Your number is smaller than 10.")
except:
    print("Please input integer number.")
```

+ 以`#`开头的语句是注释，解释器会忽略掉注释。

+ 其他每一行都是一个语句，当语句以**冒号**`:`结尾时，**缩进的语句视为代码块**（应该始终坚持使用**4个空格**的缩进）。

+ Python程序是**大小写敏感**的，如果写错了大小写，程序会报错。



### 1、数据类型

在Python中，能够直接处理的数据类型有以下几种：

+ **整数**：十六进制用`0x`前缀和0-9，a-f表示
+ **浮点数**
+ **字符串**：字符串是以单引号`'`或双引号`"`括起来的任意文本，转义字符`\`，`\n`表示换行，`\t`表示制表符，字符`\`本身也要转义，所以`\\`表示的字符就是`\`，用`r''`表示`''`内部的字符串默认不转义。用`'''...'''`的格式表示多行内容。
+ **布尔值**：只有`True`、`False`两种值，可以用`and`、`or`和`not`运算
+ **空值**：是Python里一个特殊的值，用`None`表示
+ 此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型

**变量名**必须是大小写英文、数字和`_`的组合，且不能用数字开头。等号`=`是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量。

这种变量本身类型不固定的语言称之为***动态语言***，与之对应的是***静态语言***。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。

Python中，通常用**全部大写**的变量名**表示常量**。

整数的地板除`//`永远是整数，即使除不尽。要做精确的除法，使用`/`就可以。

Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的。Python的浮点数也没有大小限制，但是超出一定范围就直接表示为`inf`（无限大）。

### 2、字符编码

UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。ASCII编码实际上可以被看成是UTF-8编码的一部分。

在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。

+ Python 3中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言。对于单个字符的编码，Python提供了`ord()`函数获取字符的整数表示，`chr()`函数把编码转换为对应的字符。
+ Python的字符串类型是`str`，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把`str`变为以字节为单位的`bytes`。对`bytes`类型的数据用带`b`前缀的单引号或双引号表示。
+ 纯英文的`str`可以用`ASCII`编码为`bytes`，内容是一样的，含有中文的`str`可以用`UTF-8`编码为`bytes`。含有中文的`str`无法用`ASCII`编码，因为中文编码的范围超过了`ASCII`编码的范围，Python会报错。反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是`bytes`。要把`bytes`变为`str`，就需要用`decode()`方法
+ 如果`bytes`中只有一小部分无效的字节，可以传入`errors='ignore'`忽略错误的字节 “xxxxx”.decode('utf-8', errors='ignore')
+ 要计算`str`包含多少个字符，可以用`len()`函数，如果换成`bytes`，`len()`函数就计算字节数
+ 应当始终坚持使用UTF-8编码对`str`和`bytes`进行转换
+ 如果`.py`文件本身使用UTF-8编码，并且也申明了`# -*- coding: utf-8 -*-`，打开命令提示符测试就可以正常显示中文
+ Python中，字符串输出采用的格式化方式和C语言是一致的，用`%`实现。在字符串内部，`%s`表示用字符串替换，`%d`表示用整数替换，有几个`%?`占位符，后面就跟几个变量或者值，顺序要对应好
+ 另一种格式化字符串的方法是使用字符串的`format()`方法，它会用传入的参数依次替换字符串内的占位符`{0}`、`{1}`……



### 3、list和tuple

> list和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。

list是一种有序的集合，可以随时添加和删除其中的元素。`classmates = ['Michael', 'Bob', 'Tracy']`

用`len()`函数可以获得list元素的个数。用索引来访问list中每一个位置的元素，记得索引是从`0`开始的。当索引超出了范围时，Python会报一个`IndexError`错误，所以，要确保索引不要越界，记得最后一个元素的索引是`len(classmates) - 1`。如果要取最后一个元素，除了计算索引位置外，还可以用`-1`做索引，直接获取最后一个元素。

list是一个可变的有序表，所以，可以往list中追加元素到末尾`append("xxx")`。把元素插入到指定的位置，比如索引号为`1`的位置`insert(1,"ccc")`。要删除list末尾的元素，用`pop()`方法。要删除指定位置的元素，用`pop(i)`方法，其中`i`是索引位置。要把某个元素替换成别的元素，可以直接赋值给对应的索引位置。

list里面的元素的数据类型也可以不同。list元素也可以是另一个list。



另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改。` classmates = ('Michael', 'Bob', 'Tracy')`。

没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用`classmates[0]`，`classmates[-1]`，但不能赋值成另外的元素。

因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。

因为括号`()`既可以表示tuple，又可以表示数学公式中的小括号，只有1个元素的tuple定义时必须加一个逗号`,`，来消除歧义。如果要定义一个空的tuple，可以写成`()`。

tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向`'a'`，就不能改成指向`'b'`，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！



### 4、判断、循环

`elif`是`else if`的缩写

```python
if <条件判断1>:
    <执行1>
elif <条件判断2>:
    <执行2>
elif <条件判断3>:
    <执行3>
else:
    <执行4>
```

`input()`返回的数据类型是`str`，`str`不能直接和整数比较，必须先把`str`转换成整数。

Python的**循环有两种**，一种是for...in循环，依次把list或tuple中的每个元素迭代出来。`for x in ...`循环就是把每个元素代入变量`x`，然后执行缩进块的语句。

Python提供一个`range()`函数，可以生成一个整数序列，再通过`list()`函数可以转换为list。比如`range(5)`生成的序列是从0开始小于5的整数。

第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。

在循环中，`break`语句可以提前退出循环。

在循环过程中，也可以通过`continue`语句，跳过当前的这次循环，直接开始下一次循环。



### 5、dict和set

Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。

```python
d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
```

dict在内部就可以直接计算出`Michael`对应的存放成绩的“页码”，也就是`95`这个数字存放的内存地址，直接取出来，所以速度非常快。把数据放入dict的方法，除了初始化时指定外，还可以通过key放入。由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉。

如果key不存在，dict就会报错。要避免key不存在的错误，有两种办法，一是通过`in`判断key是否存在。二是通过dict提供的`get()`方法，如果key不存在，可以返回`None`，或者自己指定的value。返回`None`的时候Python的交互环境不显示结果。

要删除一个key，用`pop(key)`方法，对应的value也会从dict中删除。dict内部存放的顺序和key放入的顺序是没有关系的。

> 和list比较，dict有以下几个特点：
>
> 1. 查找和插入的速度极快，不会随着key的增加而变慢；
> 2. 需要占用大量的内存，内存浪费多。
>
> 而list相反：
>
> 1. 查找和插入的时间随着元素的增加而增加；
> 2. 占用空间小，浪费内存很少。

dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的**key**必须是**不可变对象**。这个通过key计算位置的算法称为哈希算法（Hash）。



set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。

```python
 s = set([1, 2, 3])
```

传入的参数`[1, 2, 3]`是一个list，而显示的`{1, 2, 3}`只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。通过`add(key)`方法可以添加元素到set中，可以重复添加，但不会有效果。通过`remove(key)`方法可以删除元素。

set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。

**对于不变对象来说**，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。



## 二、函数

函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”。

定义一个函数要使用`def`语句，依次写出**函数名、括号、括号中的参数和冒号**`:`，然后，在缩进块中编写函数体，函数的返回值用`return`语句返回。

```python
def my_abs(x):
     if not isinstance(x, (int, float)):
        raise TypeError('bad operand type') #类型检查
    if x >= 0:
        return x
    else:
        return -x
```

如果没有`return`语句，函数执行完毕后也会返回结果，只是结果为`None`。`return None`可以简写为`return`

在Python交互环境中定义函数时，注意Python会出现`...`的提示。函数定义结束后需要按两次回车重新回到`>>>`提示符下。

在该文件的当前目录下启动Python解释器，用`from abstest import my_abs`来导入`my_abs()`函数，注意`abstest`是文件名（不含`.py`扩展名）。

如果想定义一个什么事也不做的空函数，可以用`pass`语句：

```python
def nop():
    pass  # 可以用来作为占位符，比如现在还没想好怎么写函数的代码
```

调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出`TypeError`。

在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。

除了正常定义的必选参数外，还可以使用**默认参数**、**可变参数**和**关键字参数**，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。

```python
def power(x, n=2):
    s = 1
    while n > 0:
        n = n - 1
        s = s * x
    return s
```

默认参数可以简化函数的调用。设置默认参数时，有几点要注意：

+  一是必选参数在前，默认参数在后，否则Python的解释器会报错

+  二是如何设置默认参数。

当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。

当不按顺序提供部分默认参数时，需要把参数名写上。比如调用`enroll('Adam', 'M', city='Tianjin')`，意思是，`city`参数用传进去的值，其他默认参数继续使用默认值。

Python函数在定义的时候，默认参数`L`的值就被计算出来了，即`[]`，因为默认参数`L`也是一个变量，它指向对象`[]`，每次调用该函数，如果改变了`L`的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的`[]`了。**定义默认参数要牢记一点：默认参数必须指向不变对象！**



**定义可变参数**和定义一个list或tuple参数相比，仅仅在参数前面加了一个`*`号。在函数内部，参数`numbers`接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数。Python允许你在list或tuple前面加一个`*`号，把list或tuple的元素变成可变参数传进去



**关键字参数**允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。

```python
def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)
    
>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, **extra)
```

`**extra`表示把`extra`这个dict的所有key-value用关键字参数传入到函数的`**kw`参数，`kw`将获得一个dict，注意`kw`获得的dict是`extra`的一份拷贝，对`kw`的改动不会影响到函数外的`extra`。

如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收`city`和`job`作为关键字参数。这种方式定义的函数如下：

```python
def person(name, age, *, city, job):
    print(name, age, city, job)
    
#和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。
#命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错
>>> person('Jack', 24, city='Beijing', job='Engineer')
```

> 在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。
>
> 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！
>
> 要注意定义可变参数和关键字参数的语法：
>
> `*args`是可变参数，args接收的是一个tuple；
>
> `**kw`是关键字参数，kw接收的是一个dict。



## 三、高级特性

### 1、切片

取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。

+ `L[0:3]`表示，从索引`0`开始取，直到索引`3`为止，但不包括索引`3`。即索引`0`，`1`，`2`，正好是3个元素。
+ 如果第一个索引是`0`，还可以省略。L[:3]
+ Python支持`L[-1]`取倒数第一个元素，那么它同样支持倒数切片
+ 甚至什么都不写，只写`[:]`就可以原样复制一个list
+ tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple
+ 字符串`'xxx'`也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串
+ Python的切片非常灵活，一行代码就可以实现很多行循环才能完成的操作。

### 2、迭代

在Python中，迭代是通过`for ... in`来完成的。Python的`for`循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。

list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代。因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。

默认情况下，dict迭代的是key。如果要迭代value，可以用`for value in d.values()`，如果要同时迭代key和value，可以用`for k, v in d.items()`。

判断一个对象是可迭代对象：方法是通过collections模块的Iterable类型判断

```python
>>> from collections import Iterable
>>> isinstance('abc', Iterable) # str是否可迭代
True
>>> isinstance([1,2,3], Iterable) # list是否可迭代
True
>>> isinstance(123, Iterable) # 整数是否可迭代
False

>>> x = 'abc'
>>> y = 123
>>> isinstance(x, str)
True
>>> isinstance(y, str)
False
```

Python内置的`enumerate`函数可以把一个list变成索引-元素对，这样就可以在`for`循环中同时迭代索引和元素本身：

```python
>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)
...
0 A
1 B
2 C
```

### 3、列表生成式

列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。

```python
>>> list(range(1, 11))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

>>> [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

>>> [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]

>>> [m + n for m in 'ABC' for n in 'XYZ']
['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']

>>> import os # 导入os模块，模块的概念后面讲到
>>> [d for d in os.listdir('.')] # os.listdir可以列出文件和目录
['.emacs.d', '.ssh', '.Trash', 'Adlm', 'Applications', 'Desktop', 'Documents', 'Downloads', 'Library', 'Movies', 'Music', 'Pictures', 'Public', 'VirtualBox VMs', 'Workspace', 'XCode']

>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
>>> [k + '=' + v for k, v in d.items()]
['y=B', 'x=A', 'z=C']
```

### 4、生成式

如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。

要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的`[]`改成`()`，就创建了一个generator

```python
>>> L = [x * x for x in range(10)] # 列表生成式
>>> L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

>>> g = (x * x for x in range(10)) # 生成式
>>> g
<generator object <genexpr> at 0x1022ef630>

#L是一个list，而g是一个generator
#可以通过next()函数获得generator的下一个返回值
>>> next(g)
0
>>> next(g)
1
>>> next(g)
4
# generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。
# 我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，并且不需要关心StopIteration的错误。
```

### 5、迭代式

可以直接作用于`for`循环的数据类型有以下几种：

一类是集合数据类型，如`list`、`tuple`、`dict`、`set`、`str`等；

一类是`generator`，包括生成器和带`yield`的generator function。

这些可以直接作用于`for`循环的对象统称为可迭代对象：`Iterable`。

Python的`Iterator`对象表示的是一个数据流，Iterator对象可以被`next()`函数调用并不断返回下一个数据，直到没有数据时抛出`StopIteration`错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过`next()`函数实现按需计算下一个数据，所以`Iterator`的计算是惰性的，只有在需要返回下一个数据时它才会计算。

Python的`for`循环本质上就是通过不断调用`next()`函数实现的



## 四、函数式编程