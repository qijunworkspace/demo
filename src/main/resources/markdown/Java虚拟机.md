# Java虚拟机

### 1. Java内存模型 JMM

Java虚拟机规范中定义了Java内存模型（Java Memory Model，JMM）从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：**线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本**。

+ 用于**屏蔽掉各种硬件和操作系统的内存访问差异**，以实现让Java程序在各种平台下都能达到**一致的并发效果**
+ JMM规范了Java虚拟机与**计算机内存**是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。

**为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。**通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。**它与处理器有关、与缓存有关、与并发有关、与编译器也有关**。解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的可见性、原子性和有序性。



#### 1.1 硬件内存架构

当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。

**缓存一致性问题**：在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory）。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题：缓存一致性（CacheCoherence）。

**指令重排序问题**：为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化。

**缓存一致性问题**其实就是**可见性问题**。而**处理器优化**是可以导致**原子性问题**的。**指令重排**即会导致**有序性问题**。



#### 1.2  JMM与硬件架构

![JMM与主内存](/img/jmm_1.jpg)

JMM定义了线程和主内存之间的抽象关系：

+ 线程之间的**共享变量**存储在**主内存 **Main Memory中。
+ 每个线程都有一个**私有的本地内存** Local Memory (可以理解为**工作内存**)，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。本地内存中存储了该线程以读/写共享变量的拷贝副本。
+ 主内存就是硬件的内存，而为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。当一个CPU需要访问主存时，会先读取一部分主存数据到CPU缓存，进而在读取CPU缓存到寄存器。当CPU需要写数据到主存时，同样会先flush寄存器到CPU缓存，然后再在某些节点把缓存数据flush到主存。

![JMM抽象结构图](/img/jmm_2.jpg)

JMM定义了**八种基本操作**完成主内存与工作内存之间的具体交互协议（个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节）：

+ **锁定 LOCK** ：作用于主内存的变量，把一个变量标识为一条线程独占状态
+ **解锁 UNLOCK** ：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
+ **读取 READ** ：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
+ **载入 LOAD** ：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中
+ **使用 USE** ：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作
+ **赋值 ASSIGN** : 作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
+ **存储 STORE** : 作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作
+ **写入 WRITE** : 作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。

操作规则：

+ 如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。
+ 不允许read和load、store和write操作之一单独出现
+ 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。
+ 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中
+ 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
+ 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现
+ 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
+ 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）



#### 1.3 JMM 解决的问题

1、**指令序列的重排序**：编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在**数据依赖**关系的两个操作的执行顺序。不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。（编译器、runtime和处理器都必须遵守as-if-serial语义）

+ **1、编译器优化**的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

+ **2、指令级并行**的重排序。现代**处理器**采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

+ **3、内存系统**的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

  > 上述1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。

重排序可能会导致多线程程序出现**内存可见性**问题。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的**内存屏障（Memory Barriers）指令**，通过内存屏障指令来禁止特定类型的处理器重排序。  Memory Barrier所做的另外一件事是强制刷出各种CPU cache，如一个`Write-Barrier`（写入屏障）将刷出所有在Barrier之前写入 cache 的数据，因此，任何CPU上的线程都能读取到这些数据的最新版本。

2、**使用原子性保证多线程写同步问题**：原子性变量操作包括read、load、assign、use、store、write，我们大致可以认为基本数据类型变量、引用类型变量、声明为volatile的任何类型变量的**访问读写**是具备原子性的。如果应用场景需要一个更大范围的原子性保证，需要使用同步块技术。Java内存模型提供了lock和unlock操作来满足这种需求。虚拟机提供了字节码指令monitorenter和monitorexist来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步快——synchronized关键字。

Java语言提供了**volatile**和**synchronized**两个关键字来保证线程之间操作的**有序性**：

+ volatile关键字本身就包含了禁止指令重排序的语义，volatile是基于Memory Barrier实现的
+ synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入



#### 1.4  JVM 对 JMM 的实现

在JVM内部，Java内存模型把内存分成了两部分：线程栈区和堆区：

![JVM_JMM](/img/jmm_3.jpg)

![JVM_MEMORY](/img/jvm_memory.png)

+ **虚拟机栈**：每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息。栈的大小可以固定也可以动态扩展。所有**原始类型**(boolean,byte,short,char,int,long,float,double)的本地变量都直接保存在线程栈当中，对于它们的值各个线程之间都是独立的。

+ **本地方法栈**：这部分主要与虚拟机用到的 Native 方法相关

+ **PC 寄存器**，也叫程序计数器。JVM支持多个线程同时运行，每个线程都有自己的程序计数器。倘若当前执行的是 JVM 的方法，则该寄存器中保存当前执行指令的地址；倘若执行的是native 方法，则PC寄存器中为空。

+ **方法区**也是所有线程共享。主要用于存储**类的信息、常量池、方法数据、方法代码**等。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。

+ **堆区**包含了Java应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如Byte、Integer、Long等等）。不管对象是属于一个成员变量还是方法中的本地变量，它都会被存储在堆区。

  > 一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。
  >
  > 方法区是JVM的规范，在JDK1.7中称为PermGen space，在JDK1.8之后改成Metaspace（元空间）：
  >
  > + JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如**符号引用**(Symbols，编译时生成的对某个对象的引用) 转移到了native heap；**字面量**(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。
  > +  JDK 1.8中 PermSize 和 MaxPermGen 已经无效 ，JDK 1.8 中已经不存在永久代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：**元空间并不在虚拟机中，而是使用本地内存**。
  > + 默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：
  >   + **-XX:MetaspaceSize**，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。
  >   + **-XX:MaxMetaspaceSize**，最大空间，默认是没有限制的。
  > + 为什么改成本地内存：
  >
  > ​       1、字符串存在永久代中，容易出现性能问题和内存溢出。
  >
  > 　　2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。永久代的垃圾收集是和老年代(old generation)捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。
  >
  > 　　3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。